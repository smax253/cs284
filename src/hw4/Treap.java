package hw4;

import java.util.Random;
import java.util.Stack;

/**
 * Treap class that implements a binary search tree with heap priorities.
 * I pledge my honor that I have abided by the Stevens Honor System
 * Implemented for CS 284 B
 * @author Max Shi
 * @param <E> Type of data the Treap stores. Must be Comparable
 */
public class Treap<E extends Comparable<E>> {
    /**
     * Private Inner Node class used to build Tree
     * @param <F> Type of data analogous to E in the wrapper class
     */
    private class Node<F> {
        public F data;
        public int priority;
        public Node<F> left;
        public Node<F> right;

        /**
         * Constructor for Node private inner class
         * @param data The data to be stored in the Node
         * @param priority The associated priority with this node
         */
        public Node(F data, int priority) {
            this.data = data;
            this.priority = priority;
        }

        /**
         * Rotate the tree with this node as the root to the right, returning the new root.
         * @return The new root of the tree
         */
        public Node<F> rotateRight() {
            Node<F> newHead = left;
            Node<F> temp = newHead.right;
            newHead.right = this;
            this.left = temp;
            return newHead;
        }

        /**
         * Rotate the tree with this node as the root to the left, returning the new root.
         * @return The new root of the tree
         */
        public Node<F> rotateLeft() {
            Node<F> newHead = right;
            Node<F> temp = newHead.left;
            newHead.left = this;
            this.right = temp;
            return newHead;
        }

        /**
         * Returns whether this and another object are equal.
         * Will return false if object is not of type Node&lt;E&gt; as well
         * @param other The other object to compare this Node with
         * @return If other is an object of type Node&lt;E&gt; and data and priority are equal, true; otherwise, false
         */
        public boolean equals(Object other) {
            Node<F> otherNode = null;
            try {
                otherNode = (Node<F>) other;
            } catch (Exception e) {
                return false;
            }
            if (otherNode == null) return false;
            else return data.equals(otherNode.data) && priority == otherNode.priority;
        }

        /**
         * Returns a String representation of this object
         * @return The String representation of this object
         */
        public String toString() {
            return String.format("(key=%s, priority=%d)", data.toString(), priority);
        }
    }
    //instance variables
    private Random priorityGenerator;
    private Node<E> root;

    /**
     * Default constructor for the Treap Class, initializes default priority generator.
     */
    public Treap() {
        priorityGenerator = new Random();
    }

    /**
     * Constructor for the Treap Class that initializes the priority generator with a seed
     * @param seed The seed to initialize the priority generator with
     */
    public Treap(long seed) {
        priorityGenerator = new Random(seed);
    }

    /**
     * Adds the given key to the Treap with random priority generated by priority generator
     * @param key The key to be added to the Treap.
     * @throws IllegalArgumentException If the key is a duplicate of another key in the Treap.
     * @return true if the key was added successfully, false otherwise.
     */
    public boolean add(E key) {
        return add(key, priorityGenerator.nextInt());
    }

    /**
     * Adds the given key with the given priority to the Treap
     * @param key The key to be added to the Treap.
     * @param priority The priority of the given key.
     * @throws IllegalArgumentException If the key is a duplicate of another key in the Treap.
     * @return true if the key was added successfuly, false otherwise.
     */
    public boolean add(E key, int priority) {
        Stack<Node<E>> prevNodes = new Stack<>();
        Node<E> current = root;
        Node<E> addNode = new Node<>(key, priority);
        boolean dir = false;
        while (current != null) {
            prevNodes.push(current);
            if (key.equals(current.data)) throw new IllegalArgumentException();
            if (key.compareTo(current.data) > 0) {
                current = current.right;
                dir = true;
            } else {
                current = current.left;
                dir = false;
            }
        }
        Node<E> previous = prevNodes.empty() ? null : prevNodes.peek();
        if (previous == null) root = addNode;
        else if (dir) previous.right = addNode;
        else previous.left = addNode;
        reheap(prevNodes);
        return true;
    }

    /**
     * Private helper method to make the correct rotation in the tree
     * @param current The root of the tree to be rotated
     * @return The new root of the tree
     */
    private Node<E> makeRotation(Node<E> current) {
        if (current.left != null && current.left.priority > current.priority) {
            current = current.rotateRight();
        } else if (current.right != null && current.right.priority > current.priority) {
            current = current.rotateLeft();
        }
        return current;
    }

    /**
     * Private method to restore the heap priorities of the Treap
     * @param nodeStack The Stack representing the traversal of nodes in the add method
     */
    private void reheap(Stack<Node<E>> nodeStack) {
        if (nodeStack.empty()) return;
        else if (nodeStack.size() == 1) {
            Node<E> current = nodeStack.pop();
            current = makeRotation(current);
            root = current;
        } else {
            Node<E> current = nodeStack.pop();
            Node<E> parent = nodeStack.peek();
            boolean parentdir = false;
            if (parent.right != null && parent.right.equals(current)) parentdir = true;
            current = makeRotation(current);
            if (parentdir) parent.right = current;
            else parent.left = current;
        }
        reheap(nodeStack);
    }

    /**
     * Deletes the given key from the Treap, maintaining BST and priority invariances
     * @param key The key to delete from the Tree
     * @return true if the key was successfully found and deleted, false otherwise.
     */
    public boolean delete(E key) {
        Node<E> prev = null;
        Node<E> current = root;
        boolean dir = false;
        while (current != null && !key.equals(current.data)) {
            prev = current;
            if (key.compareTo(current.data) > 0) {
                current = current.right;
                dir = true;
            } else if (key.compareTo(current.data) < 0) {
                current = current.left;
                dir = false;
            }
        }
        if (current == null) return false;
        while (current != null && (current.left != null || current.right != null)) {
            if (prev == null) prev = root;
            boolean rotateDir = false;
            if (current.right == null) rotateDir = true;
            else if (current.left == null) rotateDir = false;
            else if (current.right.priority > current.left.priority) rotateDir = false;
            else rotateDir = true;
            if (rotateDir) {
                if (dir) {
                    prev.right = current.rotateRight();
                    prev = prev.right;
                } else {
                    prev.left = current.rotateRight();
                    prev = prev.left;
                }
                current = prev.right;
                dir = true;
            } else {
                if (dir) {
                    prev.right = current.rotateLeft();
                    prev = prev.right;
                } else {
                    prev.left = current.rotateLeft();
                    prev = prev.left;
                }
                current = prev.left;
                dir = false;
            }
        }
        if(current.equals(root)) root = null;
        else if (dir) prev.right = null;
        else prev.left = null;
        return true;

    }

    /**
     * Private helper method to find an element in the Treap, recursively traverses parent a children until key is either found or root is null
     * @param root The root of the tree to explore
     * @param key The key to search for
     * @return true if the element is in the tree, false otherwise.
     */
    private boolean find(Node<E> root, E key) {
        if (root == null) return false;
        else if (root.data.equals(key)) return true;
        else return (find(root.left, key) || find(root.right, key));
    }

    /**
     * Searches Treap for the given key
     * @param key The key to find in the Treap
     * @return true if the key is in the Treap, false otherwise
     */
    public boolean find(E key) {
        return find(root, key);
    }

    /**
     * Recursively generates and returns a String representation of the Tree
     * @param node The root node of the Treap to start from
     * @param level The level of the given root node
     * @return A string representation of the Treap from the root node
     */
    private String traverse(Node<E> node, int level) {
        String leftString = "", rightString = "";
        StringBuilder s = new StringBuilder();
        s.append(level == 0 ? "" : "\n");
        for (int i = 0; i < level; i++) {
            s.append("  ");
        }
        if (node != null) {
            leftString = traverse(node.left, level + 1);
            rightString = traverse(node.right, level + 1);
            return s.append(node.toString()).append(leftString).append(rightString).toString();
        } else {
            return s.append("null").toString();
        }
    }

    /**
     * Returns a String representation of the Treap
     * @return The String representation of the Treap
     */
    public String toString() {
        return traverse(root, 0);
    }

}
